-- ft.doc-page:
toc: $ft.toc

-- ft.h2: Hello, World!


설치도 마쳤으니, 러스트 프로그램을 만들어 봅시다.
새 언어를 배울 때면 늘 그렇듯,
만들어 볼 프로그램은 화면에 `Hello, world!` 문자를 출력하는 간단한 프로그램입니다.

> Note:
> 이 책은 커맨드라인 위주로 설명하고 있습니다.
> 하지만 러스트에는 코드 작성 및 개발 도구 사용환경에 따로 정해진 규정이 없으므로
> 커맨드라인 대신 IDE(통합 개발 환경)를 사용하실 분은 애용하는 IDE를 사용하셔도 좋습니다.
> (요즘은 IDE 대부분이 러스트를 어느 정도 지원하니 세부사항은 각 IDE 문서를 참고 바랍니다)
> 러스트 팀도 최근 들어 IDE 지원 수준을 높이는 데 집중하고 있으며,
> 빠른 진전을 보여주는 중입니다.

-- ft.h3: 프로젝트 디렉토리 생성


작성할 러스트 코드를 저장해둘 디렉토리가 필요하겠죠.
러스트 코드 자체는 어디에 저장하건 실행하는 데 문제는 없습니다만,
이 책을 보며 연습하시는 분들은 편의를 위해 홈 디렉토리 내
*projects* 디렉토리를 생성해 각종 프로젝트를 보관하심을 권장해 드립니다.

터미널을 열고 다음 명령어를 입력해 *projects* 디렉토리를 생성한 후,
*projects* 내에 Hello, world! 프로젝트용 디렉토리를 만들어봅시다.

Linux, macOS, 윈도우 PowerShell 에선 다음 명령어를 입력해주세요:

-- ft.code:
lang: text

\$ mkdir ~/projects
\$ cd ~/projects
\$ mkdir hello_world
\$ cd hello_world


-- ft.markdown:

윈도우 CMD 사용자는 다음 명령어를 입력해주세요:

-- ft.code:
lang: cmd

> mkdir "%USERPROFILE%\projects"
> cd /d "%USERPROFILE%\projects"
> mkdir hello_world
> cd hello_world


-- ft.h3: 러스트 프로그램 작성 및 실행


다음으로 *main.rs* 소스 파일을 만들어봅시다(*.rs* 확장자는 러스트 파일이라는 표시입니다).

> Note: 파일명을 지을때는 두 단어 이상으로 이루어질 경우 *helloworld.rs* 와 같이
> 붙여서 쓰는게 아닌 *hello_world.rs* 처럼 단어 사이에 언더스코어('_')를 넣는걸 권장드립니다.

*main.rs* 파일에 Listing 1-1 코드를 입력합시다.

<span class="filename">Filename: main.rs</span>

-- ft.code:
lang: rust

fn main() {
  println!("Hello, world!");
}


-- ft.markdown:

<span class="caption">Listing 1-1: `Hello, world!` 를 출력하는 프로그램</span>

-- ft.markdown:

파일을 저장하고 터미널 창으로 돌아간 뒤,
Linux, macOS 사용자는 다음 명령어를 입력합시다:

-- ft.code:
lang: text

\$ rustc main.rs
\$ ./main
Hello, world!


-- ft.markdown:

윈도우에선 `./main` 을 `.\main.exe` 로 바꿔주시면 됩니다:

-- ft.code:
lang: powershell

> rustc main.rs
> .\main.exe
Hello, world!


-- ft.markdown:

사용하시는 운영체제에 관계 없이
터미널에 `Hello, world!` 가 출력되면 정상입니다.
출력되지 않으면 [“러스트 설치 - 트러블 슈팅”](ch01-01-installation.html#troubleshooting)<!-- ignore -->
내용을 참고해 도움을 얻을 방법을 찾아보세요.

-- ft.markdown:

문제 없이 `Hello, world!` 가 출력되셨다면, 축하드립니다!
여러분은 이제 어엿한 러스트 프로그래머입니다!

-- ft.h3: Hello, world! 프로그램 뜯어보기


방금 만든 Hello, world! 프로그램을 자세히 살펴봅시다.
우선 첫 부분은 다음과 같습니다:

-- ft.code:
lang: rust

fn main() {

}


-- ft.markdown:

이 코드는 러스트에서 함수를 정의하는 코드입니다.
매개변수를 받지 않고 (함수에 매개변수가 있을땐 `()` 를 작성해야 합니다)
아무것도 반환하지 않는 `main` 이라는 함수를 선언하죠.
러스트에서 함수명이 `main` 인 함수는 특별한 함수로, 항상 가장 먼저 실행되는 함수입니다.

-- ft.markdown:

알아두실 건, 러스트에선 함수 본문을
반드시 중괄호(`{}`) 로 감싸야 한다는 겁니다.
중괄호는 함수 정의와 같은 줄에 작성하고 그 사이에
공백을 한칸 넣으면 보기 좋으니 참고하세요.

-- ft.markdown:

이 글을 쓰는 시점에 `rustfmt` 라는 자동 포맷팅 도구가 개발 중입니다.
프로젝트 내 코드들을 특정 스타일로 통일하고 싶을 때 유용한 툴이죠.
러스트 팀 측은 이 툴을 `rustc` 처럼
기본 러스트 배포에 포함하기로 계획하고 있습니다.
여러분이 이 책을 읽는 시점에 따라서는 이미 여러분 컴퓨터에
`rustfmt` 가 설치되어 있을지도 모르겠네요.

-- ft.markdown:

`main` 함수 내 코드를 살펴봅시다.

-- ft.code:
lang: rust

    println!("Hello, world!");


-- ft.markdown:

화면에 텍스트를 출력하는 코드로, 이 한줄이 Hello, world! 프로그램의 전부입니다.
하지만 이 단순한 코드에도 눈여겨 볼 것이 네 가지 들어있습니다.

-- ft.markdown:

첫 번째로, 러스트에선 탭 대신 스페이스 4칸을 사용합니다.

-- ft.markdown:

두 번째로, `println!` 는 함수가 아니라 러스트의 매크로 호출 코드입니다.
이 코드가 함수 호출 코드가 되려면 `println!` 에서 `!` 를 제외해 `println` 으로 만들어야 합니다.
매크로는 19장에서 자세히 다루며, 지금은 `!` 가 붙으면 함수가 아니라 매크로 호출 코드라는 것만 알아두시면 됩니다.

-- ft.markdown:

세 번째는 우리가 `println!` 의 인수로 넘겨준 `"Hello, world!"` 문자열이
그대로 화면에 나타난 점입니다.

-- ft.markdown:

마지막으로, 줄 끝은 세미콜론(`;`)으로 표시합니다.
해당 표현식 처리를 마쳤으며, 다음 표현식 실행 준비가 끝났다는 표시이죠.
세미콜론으로 한 줄을 마치는 건 거의 모든 러스트 코드에서 볼 수 있습니다.

-- ft.h3: 컴파일과 실행은 별개의 과정입니다


앞서 새 프로그램을 만들고 실행한 과정을
세세한 단계로 나누어 검토해봅시다.

먼저, 실행하기에 앞서 `rustc` 명령어에
소스 파일명을 넘겨주어 컴파일하는 과정이
있었습니다:

-- ft.code:
lang: text

\$ rustc main.rs


-- ft.markdown:

C 나 C++ 을 다뤄보셨다면 `gcc` 나 `clang` 사용방법과 비슷하다는 걸
눈치채셨을지도 모르겠네요.

-- ft.markdown:

러스트는 소스 파일 컴파일에 성공하면 실행 가능한 바이너리를 만들어냅니다.

-- ft.markdown:

Linux, macOS, 윈도우 PowerShell 상에서는
`ls` 명령어로 실행 파일을 확인할 수 있습니다.

-- ft.code:
lang: text

\$ ls
main  main.rs


-- ft.markdown:

윈도우 CMD 는 다음 명령어를 입력해야 합니다.(`/B` 는 파일명만 출력하는 옵션입니다.):

-- ft.code:
lang: cmd

> dir /B
main.exe
main.pdb
main.rs


-- ft.markdown:

*.rs* 확장자를 갖는 소스 파일과 실행 파일
(타 플랫폼에선 *main*, 윈도우에선 *main.exe* 입니다)을 확인할 수 있습니다.
윈도우에선 디버깅 정보가 포함된 *pdb* 확장자 파일도 볼 수 있네요.
여기서 *main* 이나 *main.exe* 를 실행하는 방법은 다음과 같습니다:

-- ft.code:
lang: text

\$ ./main # 윈도우에서는 .\main.exe


-- ft.markdown:

Hello, world! 프로젝트의 실행 파일이라면
터미널에 `Hello, world!` 가 출력될겁니다.

-- ft.markdown:

Ruby, Python, JavaScript 등 명령어 한 줄로 프로그램을 컴파일하고
실행할 수 있는 동적 프로그래밍 언어에 익숙한 분들은 컴파일과 실행이
별개의 과정으로 진행되는 게 낯설 겁니다. 하지만 이 언어들은
*.rb*, *.py*, *.js* 파일을 다른 곳에서 실행하려면 해당 언어의 구현체를 설치해야만 합니다.
반면 러스트는 *AOT(ahead-of-time-compiled)* 언어로,
컴파일과 실행이 별개인 대신 여러분의 프로그래밍을 컴파일하여 만든 실행 파일을
러스트가 설치되지 않은 곳에서도 실행할 수 있습니다.
저마다 장단점이 있는 법이죠.

-- ft.markdown:

간단한 프로그램에는 `rustc` 를 사용하는 것도 좋습니다.
다만 프로젝트가 커질수록 관리할 옵션이 많아지고, 코드 배포도 점점 번거로워지겠죠.
다음 내용에서 소개할 Cargo 가 바로 이러한 문제를 해결하는,
여러분이 앞으로 `rustc` 대신 사용할 도구입니다.
